{"ast":null,"code":"// Image handling service for future backend integration\nclass ImageService {\n  constructor() {\n    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api/v1';\n  }\n\n  // Convert file to base64 for local storage (current implementation)\n  async processImageForStorage(imageData) {\n    var _imageData$file;\n    // For now, we store images as base64 in Redux\n    // In production, this would upload to a file server/cloud storage\n    return {\n      id: imageData.id,\n      name: imageData.name,\n      size: imageData.size,\n      dataUrl: imageData.dataUrl,\n      uploadStatus: 'completed',\n      // In production, this would be the server URL\n      url: imageData.dataUrl,\n      // Add metadata for future use\n      metadata: {\n        uploadedAt: new Date().toISOString(),\n        originalName: imageData.name,\n        mimeType: (_imageData$file = imageData.file) === null || _imageData$file === void 0 ? void 0 : _imageData$file.type\n      }\n    };\n  }\n\n  // Future implementation for actual file upload\n  async uploadImage(imageData) {\n    // This would be implemented when backend is ready\n    try {\n      const formData = new FormData();\n      formData.append('image', imageData.file);\n      formData.append('name', imageData.name);\n      const response = await fetch(`${this.baseURL}/uploads/images`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          // Don't set Content-Type for FormData, let browser set it\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`Upload failed: ${response.status}`);\n      }\n      const result = await response.json();\n      return {\n        id: result.id,\n        name: result.name,\n        size: result.size,\n        url: result.url,\n        thumbnailUrl: result.thumbnail_url,\n        uploadStatus: 'completed',\n        metadata: result.metadata\n      };\n    } catch (error) {\n      console.error('Image upload failed:', error);\n      throw error;\n    }\n  }\n\n  // Batch upload for galleries\n  async uploadMultipleImages(imageArray) {\n    const uploadPromises = imageArray.map(imageData => this.uploadImage(imageData).catch(error => ({\n      ...imageData,\n      uploadStatus: 'failed',\n      error: error.message\n    })));\n    return Promise.all(uploadPromises);\n  }\n\n  // Delete image from server\n  async deleteImage(imageId) {\n    try {\n      const response = await fetch(`${this.baseURL}/uploads/images/${imageId}`, {\n        method: 'DELETE',\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`Delete failed: ${response.status}`);\n      }\n      return true;\n    } catch (error) {\n      console.error('Image deletion failed:', error);\n      throw error;\n    }\n  }\n\n  // Generate thumbnail URL (for future backend implementation)\n  getThumbnailUrl(imageUrl, size = 'small') {\n    // Current implementation returns original URL\n    // Future: return thumbnail URLs from backend\n\n    // In production with a proper backend:\n    // const sizeMap = {\n    //   small: '150x150',\n    //   medium: '300x300',\n    //   large: '600x600'\n    // };\n    // return `${imageUrl}?thumb=${sizeMap[size]}`;\n\n    return imageUrl;\n  }\n\n  // Validate image file\n  validateImage(file) {\n    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n    const maxSize = 10 * 1024 * 1024; // 10MB\n\n    if (!validTypes.includes(file.type)) {\n      throw new Error('Invalid file type. Please upload JPG, PNG, GIF, or WebP images.');\n    }\n    if (file.size > maxSize) {\n      throw new Error('File too large. Please upload images smaller than 10MB.');\n    }\n    return true;\n  }\n\n  // Compress image before upload (future enhancement)\n  async compressImage(file, maxWidth = 1920, quality = 0.8) {\n    return new Promise(resolve => {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      const img = new Image();\n      img.onload = () => {\n        // Calculate new dimensions\n        let {\n          width,\n          height\n        } = img;\n        if (width > maxWidth) {\n          height = height * maxWidth / width;\n          width = maxWidth;\n        }\n        canvas.width = width;\n        canvas.height = height;\n\n        // Draw and compress\n        ctx.drawImage(img, 0, 0, width, height);\n        canvas.toBlob(resolve, file.type, quality);\n      };\n      img.src = URL.createObjectURL(file);\n    });\n  }\n}\n\n// Export singleton instance\nexport const imageService = new ImageService();\n\n// Rails Backend Integration Notes:\n/*\nExpected Rails endpoints for image handling:\n\n1. Upload single image:\n   POST /api/v1/uploads/images\n   Content-Type: multipart/form-data\n   Body: FormData with 'image' field\n\n2. Upload multiple images:\n   POST /api/v1/uploads/images/batch\n   Content-Type: multipart/form-data\n   Body: FormData with multiple 'images[]' fields\n\n3. Delete image:\n   DELETE /api/v1/uploads/images/:id\n\n4. Get image metadata:\n   GET /api/v1/uploads/images/:id\n\nRails model structure:\n```ruby\nclass Upload < ApplicationRecord\n  has_one_attached :file\n  \n  validates :name, presence: true\n  validates :file, presence: true\n  \n  def url\n    Rails.application.routes.url_helpers.rails_blob_url(file, only_path: false)\n  end\n  \n  def thumbnail_url(size = '150x150')\n    Rails.application.routes.url_helpers.rails_representation_url(\n      file.variant(resize_to_fill: size.split('x').map(&:to_i)), \n      only_path: false\n    )\n  end\nend\n```\n\nRails controller:\n```ruby\nclass Api::V1::Uploads::ImagesController < ApplicationController\n  def create\n    @upload = Upload.new(upload_params)\n    \n    if @upload.save\n      render json: {\n        id: @upload.id,\n        name: @upload.name,\n        size: @upload.file.byte_size,\n        url: @upload.url,\n        thumbnail_url: @upload.thumbnail_url,\n        metadata: {\n          content_type: @upload.file.content_type,\n          uploaded_at: @upload.created_at\n        }\n      }, status: :created\n    else\n      render json: { errors: @upload.errors }, status: :unprocessable_entity\n    end\n  end\n  \n  private\n  \n  def upload_params\n    params.permit(:image, :name)\n  end\nend\n```\n*/\n\nexport default ImageService;","map":{"version":3,"names":["ImageService","constructor","baseURL","process","env","REACT_APP_API_URL","processImageForStorage","imageData","_imageData$file","id","name","size","dataUrl","uploadStatus","url","metadata","uploadedAt","Date","toISOString","originalName","mimeType","file","type","uploadImage","formData","FormData","append","response","fetch","method","body","headers","ok","Error","status","result","json","thumbnailUrl","thumbnail_url","error","console","uploadMultipleImages","imageArray","uploadPromises","map","catch","message","Promise","all","deleteImage","imageId","getThumbnailUrl","imageUrl","validateImage","validTypes","maxSize","includes","compressImage","maxWidth","quality","resolve","canvas","document","createElement","ctx","getContext","img","Image","onload","width","height","drawImage","toBlob","src","URL","createObjectURL","imageService"],"sources":["/home/cillianomurchu/projects/store/frontend/src/services/imageService.js"],"sourcesContent":["// Image handling service for future backend integration\nclass ImageService {\n  constructor() {\n    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api/v1';\n  }\n\n  // Convert file to base64 for local storage (current implementation)\n  async processImageForStorage(imageData) {\n    // For now, we store images as base64 in Redux\n    // In production, this would upload to a file server/cloud storage\n    return {\n      id: imageData.id,\n      name: imageData.name,\n      size: imageData.size,\n      dataUrl: imageData.dataUrl,\n      uploadStatus: 'completed',\n      // In production, this would be the server URL\n      url: imageData.dataUrl,\n      // Add metadata for future use\n      metadata: {\n        uploadedAt: new Date().toISOString(),\n        originalName: imageData.name,\n        mimeType: imageData.file?.type,\n      }\n    };\n  }\n\n  // Future implementation for actual file upload\n  async uploadImage(imageData) {\n    // This would be implemented when backend is ready\n    try {\n      const formData = new FormData();\n      formData.append('image', imageData.file);\n      formData.append('name', imageData.name);\n\n      const response = await fetch(`${this.baseURL}/uploads/images`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          // Don't set Content-Type for FormData, let browser set it\n          'Accept': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Upload failed: ${response.status}`);\n      }\n\n      const result = await response.json();\n      \n      return {\n        id: result.id,\n        name: result.name,\n        size: result.size,\n        url: result.url,\n        thumbnailUrl: result.thumbnail_url,\n        uploadStatus: 'completed',\n        metadata: result.metadata\n      };\n    } catch (error) {\n      console.error('Image upload failed:', error);\n      throw error;\n    }\n  }\n\n  // Batch upload for galleries\n  async uploadMultipleImages(imageArray) {\n    const uploadPromises = imageArray.map(imageData => \n      this.uploadImage(imageData).catch(error => ({\n        ...imageData,\n        uploadStatus: 'failed',\n        error: error.message\n      }))\n    );\n\n    return Promise.all(uploadPromises);\n  }\n\n  // Delete image from server\n  async deleteImage(imageId) {\n    try {\n      const response = await fetch(`${this.baseURL}/uploads/images/${imageId}`, {\n        method: 'DELETE',\n        headers: {\n          'Accept': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Delete failed: ${response.status}`);\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Image deletion failed:', error);\n      throw error;\n    }\n  }\n\n  // Generate thumbnail URL (for future backend implementation)\n  getThumbnailUrl(imageUrl, size = 'small') {\n    // Current implementation returns original URL\n    // Future: return thumbnail URLs from backend\n    \n    // In production with a proper backend:\n    // const sizeMap = {\n    //   small: '150x150',\n    //   medium: '300x300',\n    //   large: '600x600'\n    // };\n    // return `${imageUrl}?thumb=${sizeMap[size]}`;\n    \n    return imageUrl;\n  }\n\n  // Validate image file\n  validateImage(file) {\n    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n    const maxSize = 10 * 1024 * 1024; // 10MB\n\n    if (!validTypes.includes(file.type)) {\n      throw new Error('Invalid file type. Please upload JPG, PNG, GIF, or WebP images.');\n    }\n\n    if (file.size > maxSize) {\n      throw new Error('File too large. Please upload images smaller than 10MB.');\n    }\n\n    return true;\n  }\n\n  // Compress image before upload (future enhancement)\n  async compressImage(file, maxWidth = 1920, quality = 0.8) {\n    return new Promise((resolve) => {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      const img = new Image();\n\n      img.onload = () => {\n        // Calculate new dimensions\n        let { width, height } = img;\n        if (width > maxWidth) {\n          height = (height * maxWidth) / width;\n          width = maxWidth;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        // Draw and compress\n        ctx.drawImage(img, 0, 0, width, height);\n        \n        canvas.toBlob(resolve, file.type, quality);\n      };\n\n      img.src = URL.createObjectURL(file);\n    });\n  }\n}\n\n// Export singleton instance\nexport const imageService = new ImageService();\n\n// Rails Backend Integration Notes:\n/*\nExpected Rails endpoints for image handling:\n\n1. Upload single image:\n   POST /api/v1/uploads/images\n   Content-Type: multipart/form-data\n   Body: FormData with 'image' field\n\n2. Upload multiple images:\n   POST /api/v1/uploads/images/batch\n   Content-Type: multipart/form-data\n   Body: FormData with multiple 'images[]' fields\n\n3. Delete image:\n   DELETE /api/v1/uploads/images/:id\n\n4. Get image metadata:\n   GET /api/v1/uploads/images/:id\n\nRails model structure:\n```ruby\nclass Upload < ApplicationRecord\n  has_one_attached :file\n  \n  validates :name, presence: true\n  validates :file, presence: true\n  \n  def url\n    Rails.application.routes.url_helpers.rails_blob_url(file, only_path: false)\n  end\n  \n  def thumbnail_url(size = '150x150')\n    Rails.application.routes.url_helpers.rails_representation_url(\n      file.variant(resize_to_fill: size.split('x').map(&:to_i)), \n      only_path: false\n    )\n  end\nend\n```\n\nRails controller:\n```ruby\nclass Api::V1::Uploads::ImagesController < ApplicationController\n  def create\n    @upload = Upload.new(upload_params)\n    \n    if @upload.save\n      render json: {\n        id: @upload.id,\n        name: @upload.name,\n        size: @upload.file.byte_size,\n        url: @upload.url,\n        thumbnail_url: @upload.thumbnail_url,\n        metadata: {\n          content_type: @upload.file.content_type,\n          uploaded_at: @upload.created_at\n        }\n      }, status: :created\n    else\n      render json: { errors: @upload.errors }, status: :unprocessable_entity\n    end\n  end\n  \n  private\n  \n  def upload_params\n    params.permit(:image, :name)\n  end\nend\n```\n*/\n\nexport default ImageService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}